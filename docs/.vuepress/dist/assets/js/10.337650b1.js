(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{351:function(t,n,a){"use strict";a.r(n);var s=a(43),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("p",[t._v("栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。"),a("br"),t._v("\n栈被称为一种后入先出（LIFO，last-in-first-out）的数据结构。所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。")]),t._v(" "),a("h2",{attrs:{id:"栈的基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈的基本操作"}},[t._v("#")]),t._v(" 栈的基本操作")]),t._v(" "),a("ul",[a("li",[t._v("入栈使用 push() 方法。")]),t._v(" "),a("li",[t._v("出栈使用 pop() 方法。")]),t._v(" "),a("li",[t._v("peek() 方法则只返回栈顶元素，")]),t._v(" "),a("li",[t._v("而不删除它。clear() 方法清除栈内所有元素。")]),t._v(" "),a("li",[t._v("length 属性记录栈内元素的个数。")]),t._v(" "),a("li",[t._v("empty 属性，用以表示栈内是否含有元素")])]),t._v(" "),a("h2",{attrs:{id:"经典笔试题：出栈顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#经典笔试题：出栈顺序"}},[t._v("#")]),t._v(" 经典笔试题：出栈顺序")]),t._v(" "),a("p",[t._v("如果我们现在是有3个整型数字元素1、2、3依次进栈，会有哪些出栈次序呢?")]),t._v(" "),a("ul",[a("li",[t._v("第一种: 1、2、3进，再3、2、1出。这是最简单的最好理解的一种， 出栈次序为321。")]),t._v(" "),a("li",[t._v("第二种: 1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出栈次序为123。")]),t._v(" "),a("li",[t._v("第三种: 1进，2进，2出，1出，3进，3出。出栈次序为213。\n* 同理还有 132 和 231")])]),t._v(" "),a("h2",{attrs:{id:"栈的顺序存储-javascript实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈的顺序存储-javascript实现"}},[t._v("#")]),t._v(" 栈的顺序存储-JavaScript实现")]),t._v(" "),a("p",[t._v("线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Stack() {\n  this.dataSource = [];\n  this.top = 0;\n  this.push = push;\n  this.pop = pop;\n  this.peek = peek;\n  this.clear = clear;\n  this.empty = empty;\n  this.stackLength = stackLength;\n}\n\nfunction push(element) {\n  this.dataSource[this.top++] = element;\n}\nfunction pop() {\n  return this.dataSource[--this.top];\n}\nfunction peek() {\n  return this.dataSource[this.top - 1];\n}\nfunction clear() {\n  this.top = 0;\n}\nfunction stackLength() {\n  return this.top;\n}\nfunction empty() {\n  return this.top === 0;\n}\n")])])]),a("p",[t._v("可以看到clear和pop的时候并没有真正去除数据，只是改变top而已")]),t._v(" "),a("h2",{attrs:{id:"使用栈来解决问题-转化进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用栈来解决问题-转化进制"}},[t._v("#")]),t._v(" 使用栈来解决问题-转化进制")]),t._v(" "),a("p",[t._v("十进制到二进制：除2取余，逆序排列")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('function mulBase(num: number, base: number) {\n  let result = "";\n  if (base < 2 || base > 9) {\n    throw "wrong base";\n  } else {\n    const stack = new Stack();\n    do {\n      stack.push(num % base);\n      num = Math.floor((num /= base));\n    } while (num > 0);\n    while (stack.stackLength() > 0) {\n      result += stack.pop();\n    }\n  }\n  return result;\n}\n')])])]),a("p",[t._v("如果把一个字符串压入栈，那么栈内就存储了一个翻转的字符串")])])}),[],!1,null,null,null);n.default=e.exports}}]);